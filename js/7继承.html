<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    
<script>
// 构造函数继承（对象冒充继承）
// 改变this指向(bind call apply)
// function Cat(n,c){
//     this.name = n;
//     this.color = c;
//     this.say = function (){
//         console.log('喵喵~');
//     }
// }
// Cat.prototype.skill = function (){
//     console.log('抓老鼠');
// }

// function Dog(f,n,c){
//     this.food = f;
//     Cat.call(this,n,c);
// }

// var cat1 = new Cat('小黑','black');
// var dog1 = new Dog('骨头','大黄','yellow');
// console.log(cat1.name);
// console.log(dog1.name);
// cat1.say();
// dog1.say();
// cat1.skill();
// dog1.skill();//dog1.skill is not a function  原型上的属性方法无法继承


// 原型继承
// function Cat(n,c){
//     this.name = n;
//     this.color = c;
//     this.say = function (){
//         console.log('喵喵~');
//     }
//     // return {};
// }
// Cat.prototype.skill = function (){
//     console.log('抓老鼠');
// }

// function Dog(f){
//     this.food = f;
// }
// Dog.prototype = Cat.prototype;
// Dog.prototype = new Cat();
// Dog.prototype = Object.create(Cat.prototype);// 寄生继承
// var dog1 = new Dog('shi');
// dog1.skill();
// console.log( dog1.name );// 构造函数内部的属性方法无法继承


// 组合继承（混合继承）
function Cat(n,c){
    this.name = n;
    this.color = c;
    this.say = function (){
        console.log('喵喵~');
    }
}
Cat.prototype.skill = function (){
    console.log('抓老鼠');
}

function Dog(f,n,c){
    this.food = f;
    Cat.call(this,n,c);// 构造函数继承
}
Dog.prototype = Object.create(Cat.prototype);// 继承原型上属性方法
Dog.prototype.constructor = Dog;//指正构造器

var dog1 = new Dog('shi','二哈','blue');
console.log( dog1.food );
console.log( dog1.name );
dog1.skill();
console.log( dog1.constructor );// Cat -> Dog




// 拷贝继承
// var parentObj = {
//   name: 'xm',
//   age: 25,
//   friends: ['xw', 'xh', 'xz'],
//   showName: function(){
//     alert(this.name);
//   }
// }
// // 创建需要继承的子对象
// var childObj = {sex:'男'};
// 开始拷贝属性(浅拷贝)
// for( var i in parentObj ){
//   childObj[i] = parentObj[i];
// }
// childObj.friends.push('小红');
// childObj.friends === parentObj.friends
// console.log(parentObj.friends);

// var childObj = Object.create(parentObj);
// childObj.sex = '男';


// ES6中的class只是一种语法糖，弱化了原型、原型链的概念
// 仅仅是方便开发者使用，本质并没有改变
// class Cat{
//     constructor(n){
//         this.name = n;
//         this.hello = function (){}
//     }
//     say(){

//     }
//     abc = 123;
// }

</script>
</body>
</html>